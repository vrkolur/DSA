class Main {
	public static boolean isMatch(String s, String p) {
		//dry run this sample case on paper , if unable to understand what soln does
		// p = "a*bc" s = "abcbc"
	int i = 0, j = 0, lastWildcardIdx = -1, sBacktrackIdx = -1, nextToWildcardIdx = -1;
		while (i < s.length()) {
			if (j < p.length() && (p.charAt(j) == '?' || p.charAt(j) == s.charAt(i))) {
							// chars match

			++i;
				++j;
			} else if (j < p.length() && p.charAt(j) == '*') {
								// wildcard, so chars match - store index.

			lastWildcardIdx = j;
				nextToWildcardIdx = ++j;
				sBacktrackIdx = i;
							//storing the j+1 as from there I want to match the remaining pattern

			} else if (lastWildcardIdx == -1) {
							// no match, and no wildcard has been found.

			return false;
			} else {
							// backtrack - no match, but a previous wildcard was found.

			j = nextToWildcardIdx;
				i = ++sBacktrackIdx;
			//backtrack string from previousbacktrackidx + 1 index to see if then new j and i have same chars, if that is the case that means wildcard can absorb the chars in b/w and still further we can run the algo, if at later stage it fails we can backtrack
			}
		}
		for(int it = j; it < p.length(); it++) {
			if(p.charAt(it) != '*') {
				return false;
			}
		}
		return true;
			// true if every remaining char in p is wildcard

	}

	public static void main(String[] args) {
		String str = "baaabab";
		String pattern = "*****ba*****ab";

		if (isMatch(str, pattern)) {
			System.out.println("Yes");
		} else {
			System.out.println("No");
		}
	}
}
// Java Code for Palindrome Partitioning
// Problem
public class GFG {
	// Returns the minimum number of cuts needed
	// to partition a string such that every
	// part is a palindrome
	static int minPalPartion(String str)
	{
		// Get the length of the string
		int n = str.length();

		/* Create two arrays to build the solution
		in bottom up manner
		C[i][j] = Minimum number of cuts needed
					for palindrome partitioning
					of substring str[i..j]
		P[i][j] = true if substring str[i..j] is
					palindrome, else false
		Note that C[i][j] is 0 if P[i][j] is
		true */
		int[][] t = new int[n][n];
		boolean[][] P = new boolean[n][n];

		int i, j, k, L; // different looping variables

		// Every substring of length 1 is a palindrome
		for (i = 0; i < n; i++) {
			P[i][i] = true;
			C[i][i] = 0;
		}

		/* L is substring length. Build the solution in
		bottom up manner by considering all substrings
		of length starting from 2 to n. The loop
		structure is same as Matrix Chain Multiplication
		problem (
		See https://
		www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/
		)*/
		for (L = 2; L <= n; L++) {
			// For substring of length L, set different
			// possible starting indexes
			for (i = 0; i < n - L + 1; i++) {
				j = i + L - 1; // Set ending index

				// If L is 2, then we just need to
				// compare two characters. Else need to
				// check two corner characters and value
				// of P[i+1][j-1]
				if (L == 2)
					P[i][j]
						= (str.charAt(i) == str.charAt(j));
				else
					P[i][j]
						= (str.charAt(i) == str.charAt(j))
						&& P[i + 1][j - 1];

				// IF str[i..j] is palindrome, then
				// C[i][j] is 0
				if (P[i][j] == true)
					t[i][j] = 0;
				else {
					// Make a cut at every possible
					// localtion starting from i to j,
					// and get the minimum cost cut.
					t[i][j] = Integer.MAX_VALUE;
					for (k = i; k <= j - 1; k++)
						t[i][j] = Integer.min(
							t[i][j],
							t[i][k] + t[k + 1][j] + 1);
				}
			}
		}

		// Return the min cut value for complete
		// string. i.e., str[0..n-1]
		return t[0][n - 1];
	}
	class Solution {
    int[] arr;
    public int minAbsDifference(int[] nums, int goal) {
        arr = nums;
        int n = nums.length;
        
        
        List<Integer> first = new ArrayList<>();
        List<Integer> second = new ArrayList<>();
        
        generate(0,n/2,0, first); //generate all possible subset sums from half the array
        generate(n/2, n , 0, second);//generate all possible subset sums from the second half of the array
        
        
        Collections.sort(first);
        int ans = Integer.MAX_VALUE;
        
        
        for(int secondSetSum : second ) {
            int left = goal - secondSetSum; // How far off are we from the desired goal?
            
            if(first.get(0) > left) { // all subset sums from first half are too big => Choose the smallest
                ans = (int)(Math.min(ans, Math.abs((first.get(0) + secondSetSum) - goal)));
                continue;
            }
            if(first.get(first.size() - 1) < left) { // all subset sums from first half are too small => Choose the largest
                ans = (int)(Math.min(ans, Math.abs((first.get(first.size() - 1) + secondSetSum) - goal)));
                continue;
            }
            int pos = Collections.binarySearch(first, left);
            if(pos >= 0) // Exact match found! => first.get(pos) + secondSetSum == goal
                return 0;
            else        // If exact match not found, binarySearch in java returns (-(insertionPosition) - 1)
                pos = -1 * (pos + 1);
            int low = pos - 1;
            ans = (int)Math.min(ans, Math.abs(secondSetSum + first.get(low) - goal)); // Checking for the floor value (largest sum < goal)
            ans = (int)Math.min(ans, Math.abs(secondSetSum + first.get(pos) - goal)); //Checking for the ceiling value (smallest sum > goal)
        }
        return ans;
    }

    /**
    * Generating all possible subset sums. 2 choices at each index,i -> pick vs do not pick 
    */
    void generate(int i, int end, int sum, List<Integer> listOfSubsetSums) {
        if (i == end) {
            listOfSubsetSums.add(sum); //add
            return;
        }
        generate(i + 1, end, sum + arr[i], set);
        generate(i + 1, end, sum, set); 
        
    }
    
    
    
}